#####
##### Schema
#####

const ALLOWED_SCHEMA_NAME_CHARACTERS = Char['-', '.', 'a':'z'..., '0':'9'...]

"""
    Legolas.is_valid_schema_name(x::AbstractString)

Return `true` if `x` is a valid schema name, return `false` otherwise.

Valid schema names are lowercase, alphanumeric, and may contain hyphens or periods.
"""
is_valid_schema_name(x::AbstractString) = all(i -> i in ALLOWED_SCHEMA_NAME_CHARACTERS, x)

"""
    Legolas.Schema{name,version}

A type representing the schema of a [`Legolas.Row`](@ref). The `name` (a `Symbol`) and `version` (an `Integer`)
are surfaced as type parameters, allowing them to be utilized for dispatch.

For more details and examples, please see `Legolas.jl/examples/tour.jl` and the "Tips for Schema Authors"
section of the Legolas.jl documentation.

See also: [`schema_name`](@ref), [`schema_version`](@ref), [`schema_parent`](@ref)
"""
struct Schema{name,version} end

"""
    Legolas.Schema(name::AbstractString, version::Integer)

Return `Legolas.Schema{Symbol(name),version}()`. This constructor will throw an `ArgumentError` if `name` is
not a valid schema name.

Prefer using this constructor over `Legolas.Schema{Symbol(name),version}()` directly.
"""
function Schema(name::AbstractString, version::Integer)
    version >= 0 || throw(ArgumentError("`Legolas.Schema` version must be non-negative, recieved: $version"))
    is_valid_schema_name(name) || throw(ArgumentError("argument is not a valid `Legolas.Schema` name: \"$name\""))
    return Schema{Symbol(name),version}()
end

"""
    Legolas.Schema(s::AbstractString)

Return `Legolas.Schema(name, n)` where `s` is a valid schema identifier of the form `"name@n"`.

`s` may also be a fully qualified schema identifier of the form `"name@n>...>..."`.
"""
function Schema(s::AbstractString)
    x = split(first(split(s, '>', limit=2)), '@')
    if length(x) == 2
        name, version = x
        version = tryparse(Int, version)
        version isa Int && return Schema(name, version)
    end
    throw(ArgumentError("argument is not a valid `Legolas.Schema` string: \"$s\""))
end

"""
    schema_name(::Type{<:Legolas.Schema{name}})
    schema_name(::Legolas.Schema{name})

Return `name`.
"""
@inline schema_name(::Type{<:Schema{name}}) where {name} = name
@inline schema_name(schema::Schema) = schema_name(typeof(schema))

"""
    schema_version(::Type{Legolas.Schema{name,version}})
    schema_version(::Legolas.Schema{name,version})

Return `version`.
"""
@inline schema_version(::Type{<:Schema{name,version}}) where {name,version} = version
@inline schema_version(schema::Schema) = schema_version(typeof(schema))

"""
    schema_parent(::Type{Legolas.Schema{name,version}})
    schema_parent(::Legolas.Schema{name,version})

Return the `Legolas.Schema` instance that corresponds to the parent of the given `Legolas.Schema`.
"""
@inline schema_parent(::Type{<:Schema}) = nothing
@inline schema_parent(schema::Schema) = schema_parent(typeof(schema))

"""
    schema_qualified_string(::Type{Legolas.Schema{name,version}})

Return this `Legolas.Schema`'s fully qualified schema identifier string. This string is
serialized as the `\"$LEGOLAS_SCHEMA_QUALIFIED_METADATA_KEY\"`` field value in table
metadata for table written via [`Legolas.write`](@ref).
"""
function schema_qualified_string end

# Note that there exist very clean generic implementations of `transform`/`validate`:
#
#    function transform(schema::Schema; fields...)
#        parent = schema_parent(schema)
#        parent isa Schema && (fields = transform(parent; fields...))
#        return _transform(schema; fields...)
#    end
#
#    function validate(tables_schema::Tables.Schema, legolas_schema::Schema)
#        parent = schema_parent(legolas_schema)
#        parent isa Schema && validate(parent, tables_schema)
#        _validate(tables_schema, legolas_schema)
#        return nothing
#    end
#
# However, basic benchmarking demonstrates that the above versions can allocate
# unnecessarily for schemas with a few ancestors, while the "hardcoded" versions
# generated by the current implementation of the `@row` macro (see below) do not.

function transform end

function _transform end

"""
    Legolas.validate(tables_schema::Tables.Schema, legolas_schema::Legolas.Schema)

Throws an `ArgumentError` if `tables_schema` does comply with `legolas_schema`, otherwise
returns `nothing`.

Specifically, `tables_schema` is considered to comply with `legolas_schema` if:

- every non-`>:Missing` field required by `legolas_schema` is present in `tables_schema`.
- `T <: S` for each field `f::T` in `tables_schema` that matches a required `legolas_schema` field `f::S`.
"""
function validate end

function _validate end

function validate_expected_field(schema::Tables.Schema, name::Symbol, ::Type{T}) where {T}
    i = findfirst(==(name), schema.names)
    if isnothing(i)
        Missing <: T || throw(ArgumentError("could not find expected field `$name::$T` in $schema"))
    else
        schema.types[i] <: T || throw(ArgumentError("field `$name` has unexpected type; expected <:$T, found $(schema.types[i])"))
    end
    return nothing
end

Base.show(io::IO, schema::Schema) = print(io, "Schema(\"$(schema_name(schema))@$(schema_version(schema))\")")

# internal function to construct a NamedTuple type from a `Schema`
minimal_nt_type(::Type{S}) where {S} = NamedTuple{row_required_names(S), row_required_types(S)}

#####
##### Row
#####

"""
    Legolas.Row(schema::Schema; fields...)
    Legolas.Row(schema::Schema, row)

Return a `Legolas.Row <: Tables.AbstractRow` instance whose fields are the provided `fields`
(or the fields of `row`) validated/transformed in accordance with provided `schema`.

For more details and examples, please see `Legolas.jl/examples/tour.jl`.
"""
struct Row{S<:Schema,F} <: Tables.AbstractRow
    schema::S
    fields::F
    function Row(schema::Schema; fields...)
        fields = transform(schema; fields...)
        return new{typeof(schema),typeof(fields)}(schema, fields)
    end
    function Row{S, F}(fields::F) where {S<:Schema, F<:NamedTuple}
        if nt_names(F) != row_required_names(S) || nt_values(F) != row_required_types(S)
            error("Secret inner constructor is only for Arrow deserialization.")
        end
        schema = S()
        return new{S, F}(schema, fields)
    end
end

Row{S}(args...; kwargs...) where {S} = Row(S(), args...; kwargs...)

Row(schema::Schema, fields) = Row(schema, NamedTuple(Tables.Row(fields)))
Row(schema::Schema, fields::Row) = Row(schema, getfield(fields, :fields))
Row(schema::Schema, fields::NamedTuple) = Row(schema; fields...)

Base.propertynames(row::Row) = propertynames(getfield(row, :fields))
Base.getproperty(row::Row, name::Symbol) = getproperty(getfield(row, :fields), name)

Tables.getcolumn(row::Row, i::Int) = Tables.getcolumn(getfield(row, :fields), i)
Tables.getcolumn(row::Row, nm::Symbol) = Tables.getcolumn(getfield(row, :fields), nm)
Tables.columnnames(row::Row) = Tables.columnnames(getfield(row, :fields))

Base.:(==)(a::Row, b::Row) = getfield(a, :schema) == getfield(b, :schema) && getfield(a, :fields) == getfield(b, :fields)
Base.isequal(a::Row, b::Row) = isequal(getfield(a, :schema), getfield(b, :schema)) && isequal(getfield(a, :fields), getfield(b, :fields))

function Base.show(io::IO, row::Row)
    print(io, "Row($(getfield(row, :schema)), ")
    show(io, getfield(row, :fields))
    print(io, ")")
    return nothing
end

function _parse_schema_expr(x)
    if x isa Expr && x.head == :call && x.args[1] == :> && length(x.args) == 3
        child, _ = _parse_schema_expr(x.args[2])
        parent, _ = _parse_schema_expr(x.args[3])
        return child, parent
    end
    return nothing, nothing
end

_parse_schema_expr(str::AbstractString) = Schema(str), nothing

function row_required_names end
function row_required_types end

"""
    @row("name@version", field_expressions...)
    @row("name@version" > "parent_name@parent_version", field_expressions...)

Define a new `Legolas.Schema{name,version}` whose required fields are specified by `field_expressions`.
Returns `Legolas.Row{Legolas.Schema{name,version}}` which can be conveniently aliased to the caller's
preferred binding for a row constructor associated with `Legolas.Schema{name,version}`.

Each element of `field_expression` defines a required field for `Legolas.Schema{name,version}`, and is
an expression of the form `field::F = rhs` where:

- `field` is the corresponding field's name
- `::F` denotes the field's type constraint (if elided, defaults to `::Any`).
- `rhs` is the expression which produces `field::F` (if elided, defaults to `field`).

As implied above, the following alternative forms are also allowed:

- `field::F` (interpreted as `field::F = field`)
- `field = rhs` (interpreted as `field::Any = rhs`)
- `field` (interpreted as `field::Any = field`)

For more details and examples, please see `Legolas.jl/examples/tour.jl` and the "Tips for Schema Authors"
section of the Legolas.jl documentation.
"""
macro row(schema_expr, fields...)
    schema, parent = _parse_schema_expr(schema_expr)
    isnothing(schema) && throw(ArgumentError("`@row` schema argument must be of the form `\"name@X\"` or `\"name@X\" > \"parent@Y\"`. Received: $schema_expr"))
    fields = map(fields) do f
        original_f = f
        f isa Symbol && (f = Expr(:(::), f, :Any))
        f.head == :(::) && (f = Expr(:(=), f, f.args[1]))
        f.head == :(=) && f.args[1] isa Symbol && (f.args[1] = Expr(:(::), f.args[1], :Any))
        f.head == :(=) && f.args[1].head == :(::) || throw(ArgumentError("malformed `@row` field expression: $original_f"))
        return f
    end
    validate_fields = map(fields) do f
        name, type = f.args[1].args
        return :(validate_expected_field(tables_schema, $(Base.Meta.quot(name)), $(esc(type))))
    end
    field_names = [esc(f.args[1].args[1]) for f in fields]
    schema_type = Base.Meta.quot(typeof(schema))
    quoted_parent = Base.Meta.quot(parent)
    schema_qualified_string = string(schema_name(schema), '@', schema_version(schema))
    parent_transform = nothing
    parent_validate = nothing
    if !isnothing(parent)
        schema_qualified_string = :(string($schema_qualified_string, '>', Legolas.schema_qualified_string($quoted_parent)))
        parent_transform = :(fields = transform($quoted_parent; fields...))
        parent_validate = :(validate(tables_schema, $quoted_parent))
    end

    f_names = map(fields) do f
        name, _ = f.args[1].args
        return :($(Base.Meta.quot(name)))
    end

    f_types = map(fields) do f
        _, type = f.args[1].args
        return esc(type)
    end

    return quote
        Legolas.schema_qualified_string(::$schema_type) = $schema_qualified_string

        Legolas.schema_parent(::Type{<:$schema_type}) = $quoted_parent

        function Legolas._transform(::$schema_type; $([Expr(:kw, f, :missing) for f in field_names]...), other...)
            $(map(esc, fields)...)
            return (; $([Expr(:kw, f, f) for f in field_names]...), other...)
        end

        function Legolas._validate(tables_schema::Tables.Schema, legolas_schema::$schema_type)
            $(validate_fields...)
            return nothing
        end

        function Legolas.transform(schema::$schema_type; fields...)
            $parent_transform
            return _transform(schema; fields...)
        end

        function Legolas.validate(tables_schema::Tables.Schema, legolas_schema::$schema_type)
            $parent_validate
            return _validate(tables_schema, legolas_schema)
        end

        function Legolas.row_required_names(::Type{$schema_type})
            return tuple($(f_names...))
        end

        function Legolas.row_required_types(::Type{$schema_type})
            return Tuple{$(f_types...)}
        end

        Legolas.Row{$schema_type}
    end
end

# Serializing `Schema`'s
const SCHEMA_ARROW_NAME = Symbol("JuliaLang.Legolas.Schema")
ArrowTypes.arrowname(::Type{<:Legolas.Schema}) = SCHEMA_ARROW_NAME
ArrowTypes.JuliaType(::Val{SCHEMA_ARROW_NAME}) = Schema

# `_` is not in `ALLOWED_SCHEMA_NAME_CHARACTERS`, so we use it as a separator here:
ArrowTypes.arrowmetadata(::Type{Schema{name, version}}) where {name, version} = string(name, "_", version)

function ArrowTypes.JuliaType(::Val{SCHEMA_ARROW_NAME}, ::Type{NamedTuple{names, types}}, meta) where {names, types}
    @info 3
    name, version = split(meta, "_")
    return Schema{Symbol(name), parse(Int, version)}
end

# Serializing `Row`'s

# function ArrowTypes.arrowname(::Type{Row{S,F}}) where {S, F}
#      if nt_names(F) != row_required_names(S)
#         extras = setdiff(row_required_names(S), nt_names(F))
#         error("Can serialize an `Legolas.Row` as an element of an Arrow table when no extra columns are present. Extra columns: $extras")
#      end
#     return ROW_ARROW_NAME
# end

# ArrowTypes.arrowname(::Type{Row{S}}) where {S} = ROW_ARROW_NAME

# function ArrowTypes.JuliaType(::Val{ROW_ARROW_NAME}, ::Type{NamedTuple{struct_names, struct_types}}, meta) where {struct_names, struct_types}
#     @info 2
#     schema_type = Base.tuple_type_head(struct_types)
#     return Row{schema_type, minimal_nt_type(schema_type)}
# end

function ArrowTypes.ArrowKind(::Type{Row{S}}) where S
    return ArrowTypes.ArrowKind(minimal_nt_type(S))
end

function ArrowTypes.ArrowType(::Type{Row{S}}) where S
    return ArrowTypes.ArrowType(minimal_nt_type(S))
end

function ArrowTypes.toarrow(row::Row{S}) where S
    F = minimal_nt_type(S)
    result = convert(F, NamedTuple(row))
    @info "toarrow" result
    return result
end

ArrowTypes.arrowmetadata(::Type{Row{Schema{name, version}}}) where {name, version} = string(name, "_", version)


const ROW_ARROW_NAME = Symbol("JuliaLang.Legolas.Row")
ArrowTypes.arrowname(::Type{Row}) = ROW_ARROW_NAME

function ArrowTypes.JuliaType(::Val{ROW_ARROW_NAME}, ::Type{NamedTuple{struct_names, struct_types}}, meta) where {struct_names, struct_types}
    @info "JuliaType" meta
    name, version = split(meta, "_")
    S = Schema{Symbol(name), parse(Int, version)}
    return Row{S, minimal_nt_type(S)}
end

function ArrowTypes.fromarrow(::Type{Row{S, F}}, fields...) where {S, F}
    @info "fromarrow" fields
    # F = minimal_nt_type(S)
    # a = map(fromarrow, Tuple(nt_values(F2).types), Tuple(fields))
    # b = convert(nt_values(F), a)
    # new_fields = convert(F, NamedTuple{nt_names(F)}(b))
    return Row{S, F}(F(fields))
end

# function ArrowTypes.fromarrow(::Type{Row{S}}, schema::S, fields::F2) where {S, F2}
#     F = minimal_nt_type(S)
#     a = map(fromarrow, Tuple(nt_values(F2).types), Tuple(fields))
#     b = convert(nt_values(F), a)
#     new_fields = convert(F, NamedTuple{nt_names(F)}(b))
#     return Row{S, F}(schema, new_fields)
# end

nt_names(::Type{NamedTuple{K, V}}) where {K, V} = K
nt_values(::Type{NamedTuple{K, V}}) where {K, V} = V
